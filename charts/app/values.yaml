# Default values for app.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 1

# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  repository: nginx
  # This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  # NOTE: Using "latest" is not recommended for production. Use specific version tags.
  tag: "1.25"

# This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
# This is to override the chart name.
nameOverride: ""
fullnameOverride: ""

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# This is for setting Kubernetes Annotations to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# This is for setting Kubernetes Labels to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

# Pod-level security context
# More information: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
podSecurityContext: {}
  # runAsNonRoot: true
  # runAsUser: 65534
  # fsGroup: 65534
  # seccompProfile:
  #   type: RuntimeDefault

# Container-level security context
# For production, consider enabling these security settings:
securityContext: {}
  # allowPrivilegeEscalation: false
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 65534
  # capabilities:
  #   drop:
  #   - ALL

strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 0

# Override container command (entrypoint)
commands: []
# - /bin/sh
# - -c

# Override container args
args: []
# - "echo hello && sleep 3600"

# Container port configuration
containerPort:
  name: http
  port: 8080
  protocol: TCP

# Additional container ports
extraPorts: []
# - name: metrics
#   port: 9090
#   protocol: TCP
# - name: grpc
#   port: 50051
#   protocol: TCP

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  # This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
  port: 80
  # Target port (can be port name or number)
  targetPort: http
  # Protocol for the service port
  protocol: TCP
  # Name for the service port
  portName: http
  # Service annotations
  annotations: {}

# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# -- Expose the service via gateway-api HTTPRoute
# Requires Gateway API resources and suitable controller installed within the cluster
# (see: https://gateway-api.sigs.k8s.io/guides/)
httpRoute:
  # HTTPRoute enabled.
  enabled: false
  # HTTPRoute annotations.
  annotations: {}
  # Which Gateways this Route is attached to.
  parentRefs:
  - name: gateway
    sectionName: http
    # namespace: default
  # Hostnames matching HTTP header.
  hostnames:
  - chart-example.local
  # List of rules and filters applied.
  rules:
  - matches:
    - path:
        type: PathPrefix
        value: /headers
  #   filters:
  #   - type: RequestHeaderModifier
  #     requestHeaderModifier:
  #       set:
  #       - name: My-Overwrite-Header
  #         value: this-is-the-only-value
  #       remove:
  #       - User-Agent
  # - matches:
  #   - path:
  #       type: PathPrefix
  #       value: /echo
  #     headers:
  #     - name: version
  #       value: v2

# Resource limits and requests
# Recommended: Always set resource limits in production
# More information: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
resources: {}
  # limits:
  #   cpu: 500m
  #   memory: 512Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# Lifecycle hooks for graceful shutdown and startup
# More information: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/
lifecycle: {}
  # preStop:
  #   exec:
  #     command: ["/bin/sh", "-c", "sleep 15"]
  # postStart:
  #   exec:
  #     command: ["/bin/sh", "-c", "echo Hello from the postStart handler"]

# Environment variables as key-value pairs
env: {}
  # LOG_LEVEL: "info"
  # NODE_ENV: "production"
  # DATABASE_HOST: "db.example.com"

# Environment variables from secrets
# Reference existing secrets created outside this chart
secretEnv: {}
  # DATABASE_PASSWORD:
  #   name: db-secret
  #   key: password
  # API_KEY:
  #   name: api-credentials
  #   key: api-key

# Mount entire ConfigMaps or Secrets as environment variables
envFrom: []
  # - configMapRef:
  #     name: app-config
  # - secretRef:
  #     name: app-secrets

# This is to setup the liveness and readiness probes
# More information: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
# Supports: httpGet, tcpSocket, exec, grpc
# Note: Probes are not enabled by default. Define them explicitly based on your application needs.
livenessProbe: {}
  # httpGet:
  #   path: /healthz
  #   port: http
  #   scheme: HTTP
  # initialDelaySeconds: 30
  # periodSeconds: 10
  # timeoutSeconds: 5
  # successThreshold: 1
  # failureThreshold: 3

readinessProbe: {}
  # httpGet:
  #   path: /ready
  #   port: http
  #   scheme: HTTP
  # initialDelaySeconds: 5
  # periodSeconds: 5
  # timeoutSeconds: 3
  # successThreshold: 1
  # failureThreshold: 3

# Startup probe for slow-starting containers (Kubernetes 1.22+)
startupProbe: {}
  # httpGet:
  #   path: /healthz
  #   port: http
  # initialDelaySeconds: 0
  # periodSeconds: 10
  # timeoutSeconds: 3
  # successThreshold: 1
  # failureThreshold: 30

# This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# Pod Disruption Budget
# More information: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
pdb:
  enabled: false
  # Specify either minAvailable or maxUnavailable, not both
  minAvailable: 1
  # maxUnavailable: 1
  annotations: {}
  # unhealthyPodEvictionPolicy: IfHealthyBudget  # Kubernetes 1.26+

# Persistent Volume Claim
# More information: https://kubernetes.io/docs/concepts/storage/persistent-volumes/
pvc:
  enabled: false
  # Backward compatibility (use enabled instead)
  created: false
  name: ""  # Defaults to fullname
  annotations: {}
  accessModes:
    - ReadWriteOnce
  size: 10Gi
  storageClassName: ""  # Use default storage class if empty
  volumeMode: Filesystem
  selector: {}

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}

externalSecrets: []

# Init container configuration
# More information: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
initContainer:
  enabled: false
  name: init
  # command and args override the image's entrypoint
  commands: []
  args: []
  resources: {}
  volumeMounts: []

# Advanced Pod Scheduling and Configuration

# Pod priority for scheduling
# More information: https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/
priorityClassName: ""

# Runtime class (gVisor, Kata Containers, etc.)
# More information: https://kubernetes.io/docs/concepts/containers/runtime-class/
runtimeClassName: ""

# Termination grace period (seconds)
# More information: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination
terminationGracePeriodSeconds: 30

# Topology spread constraints for high availability
# More information: https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/
topologySpreadConstraints: []
# - maxSkew: 1
#   topologyKey: topology.kubernetes.io/zone
#   whenUnsatisfiable: DoNotSchedule
#   labelSelector:
#     matchLabels:
#       app.kubernetes.io/name: app
# - maxSkew: 1
#   topologyKey: kubernetes.io/hostname
#   whenUnsatisfiable: ScheduleAnyway
#   labelSelector:
#     matchLabels:
#       app.kubernetes.io/name: app

# ConfigMaps to create
# More information: https://kubernetes.io/docs/concepts/configuration/configmap/
configMaps: []
# - name: app-config
#   data:
#     config.yaml: |
#       key: value

# Hook/Job configuration
# For pre-install, post-install, pre-upgrade, post-upgrade hooks
hook: []
# - name: migration
#   annotations:
#     "helm.sh/hook": pre-upgrade
#     "helm.sh/hook-weight": "1"
#   image:
#     repository: migrate/migrate
#     tag: latest
#   commands:
#     - migrate
#   args:
#     - -path=/migrations
#     - up

# Application metadata (used in hooks)
app: {}
  # name: myapp
  # env: production
  # country: us

# Network Policy
# More information: https://kubernetes.io/docs/concepts/services-networking/network-policies/
networkPolicy:
  enabled: false
  policyTypes:
    - Ingress
    - Egress
  ingress: []
  # - from:
  #   - namespaceSelector:
  #       matchLabels:
  #         name: allowed-namespace
  #   ports:
  #   - protocol: TCP
  #     port: 8080
  egress: []
  # - to:
  #   - namespaceSelector: {}
  #   ports:
  #   - protocol: TCP
  #     port: 443

# Prometheus ServiceMonitor (requires Prometheus Operator)
# More information: https://github.com/prometheus-operator/prometheus-operator
monitoring:
  enabled: false
  serviceMonitor:
    enabled: false
    interval: 30s
    scrapeTimeout: 10s
    path: /metrics
    labels: {}
    # release: prometheus

# Sidecar containers configuration
# Sidecars run alongside the main container in the same pod, sharing the same network and storage.
# Common use cases: logging agents, proxies (Envoy), monitoring agents, service mesh sidecars
# More information: https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/
sidecars: []
# Example sidecar configurations:
# - name: logging-agent
#   image:
#     repository: fluent/fluent-bit
#     tag: "2.0"
#     pullPolicy: IfNotPresent
#   # Optional: Custom startup command
#   command: []
#   # - /fluent-bit/bin/fluent-bit
#   # Optional: Command arguments
#   args: []
#   # - -c
#   # - /fluent-bit/etc/fluent-bit.conf
#   # Optional: Environment variables
#   env: []
#   # - name: LOG_LEVEL
#   #   value: "info"
#   # Optional: Secret environment variables
#   secretEnv: []
#   # - name: API_KEY
#   #   valueFrom:
#   #     secretKeyRef:
#   #       name: my-secret
#   #       key: api-key
#   # Optional: Container ports
#   ports: []
#   # - name: metrics
#   #   containerPort: 2020
#   #   protocol: TCP
#   # Optional: Volume mounts (must reference volumes defined in volumes section)
#   volumeMounts: []
#   # - name: logs
#   #   mountPath: /var/log
#   #   readOnly: true
#   # Optional: Security context for the sidecar
#   securityContext: {}
#   # - runAsUser: 1000
#   # - runAsNonRoot: true
#   # - readOnlyRootFilesystem: true
#   # Optional: Resource limits and requests
#   resources: {}
#   # - limits:
#   #     cpu: 100m
#   #     memory: 128Mi
#   #   requests:
#   #     cpu: 50m
#   #     memory: 64Mi
#   # Optional: Liveness probe (supports httpGet, tcpSocket, exec, grpc)
#   livenessProbe: {}
#   # - httpGet:
#   #     path: /health
#   #     port: 2020
#   #   initialDelaySeconds: 30
#   #   periodSeconds: 10
#   #   timeoutSeconds: 5
#   # - tcpSocket:
#   #     port: 2020
#   #   initialDelaySeconds: 15
#   #   periodSeconds: 20
#   # - exec:
#   #     command:
#   #     - cat
#   #     - /tmp/healthy
#   #   initialDelaySeconds: 5
#   #   periodSeconds: 5
#   # - grpc:
#   #     port: 2020
#   #   initialDelaySeconds: 10
#   # Optional: Readiness probe (supports httpGet, tcpSocket, exec, grpc)
#   readinessProbe: {}
#   # - httpGet:
#   #     path: /ready
#   #     port: 2020
#   #   initialDelaySeconds: 5
#   #   periodSeconds: 5
#   #   timeoutSeconds: 3
#
# - name: envoy-proxy
#   image:
#     repository: envoyproxy/envoy
#     tag: "v1.28"
#     pullPolicy: IfNotPresent
#   command:
#   - envoy
#   args:
#   - -c
#   - /etc/envoy/envoy.yaml
#   ports:
#   - name: proxy
#     containerPort: 8000
#     protocol: TCP
#   - name: admin
#     containerPort: 9901
#     protocol: TCP
#   volumeMounts:
#   - name: envoy-config
#     mountPath: /etc/envoy
#     readOnly: true
#   resources:
#     limits:
#       cpu: 200m
#       memory: 256Mi
#     requests:
#       cpu: 100m
#       memory: 128Mi
#   readinessProbe:
#     httpGet:
#       path: /ready
#       port: 9901
#     initialDelaySeconds: 3
#     periodSeconds: 3

hookVolumeMounts: {}

hookVolumes: {}
